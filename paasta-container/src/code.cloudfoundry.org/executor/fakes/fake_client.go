// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"

	"code.cloudfoundry.org/executor"
	"code.cloudfoundry.org/lager"
)

type FakeClient struct {
	PingStub        func(logger lager.Logger) error
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		logger lager.Logger
	}
	pingReturns struct {
		result1 error
	}
	pingReturnsOnCall map[int]struct {
		result1 error
	}
	AllocateContainersStub        func(logger lager.Logger, requests []executor.AllocationRequest) ([]executor.AllocationFailure, error)
	allocateContainersMutex       sync.RWMutex
	allocateContainersArgsForCall []struct {
		logger   lager.Logger
		requests []executor.AllocationRequest
	}
	allocateContainersReturns struct {
		result1 []executor.AllocationFailure
		result2 error
	}
	allocateContainersReturnsOnCall map[int]struct {
		result1 []executor.AllocationFailure
		result2 error
	}
	GetContainerStub        func(logger lager.Logger, guid string) (executor.Container, error)
	getContainerMutex       sync.RWMutex
	getContainerArgsForCall []struct {
		logger lager.Logger
		guid   string
	}
	getContainerReturns struct {
		result1 executor.Container
		result2 error
	}
	getContainerReturnsOnCall map[int]struct {
		result1 executor.Container
		result2 error
	}
	RunContainerStub        func(lager.Logger, *executor.RunRequest) error
	runContainerMutex       sync.RWMutex
	runContainerArgsForCall []struct {
		arg1 lager.Logger
		arg2 *executor.RunRequest
	}
	runContainerReturns struct {
		result1 error
	}
	runContainerReturnsOnCall map[int]struct {
		result1 error
	}
	StopContainerStub        func(logger lager.Logger, guid string) error
	stopContainerMutex       sync.RWMutex
	stopContainerArgsForCall []struct {
		logger lager.Logger
		guid   string
	}
	stopContainerReturns struct {
		result1 error
	}
	stopContainerReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteContainerStub        func(logger lager.Logger, guid string) error
	deleteContainerMutex       sync.RWMutex
	deleteContainerArgsForCall []struct {
		logger lager.Logger
		guid   string
	}
	deleteContainerReturns struct {
		result1 error
	}
	deleteContainerReturnsOnCall map[int]struct {
		result1 error
	}
	ListContainersStub        func(lager.Logger) ([]executor.Container, error)
	listContainersMutex       sync.RWMutex
	listContainersArgsForCall []struct {
		arg1 lager.Logger
	}
	listContainersReturns struct {
		result1 []executor.Container
		result2 error
	}
	listContainersReturnsOnCall map[int]struct {
		result1 []executor.Container
		result2 error
	}
	GetBulkMetricsStub        func(lager.Logger) (map[string]executor.Metrics, error)
	getBulkMetricsMutex       sync.RWMutex
	getBulkMetricsArgsForCall []struct {
		arg1 lager.Logger
	}
	getBulkMetricsReturns struct {
		result1 map[string]executor.Metrics
		result2 error
	}
	getBulkMetricsReturnsOnCall map[int]struct {
		result1 map[string]executor.Metrics
		result2 error
	}
	RemainingResourcesStub        func(lager.Logger) (executor.ExecutorResources, error)
	remainingResourcesMutex       sync.RWMutex
	remainingResourcesArgsForCall []struct {
		arg1 lager.Logger
	}
	remainingResourcesReturns struct {
		result1 executor.ExecutorResources
		result2 error
	}
	remainingResourcesReturnsOnCall map[int]struct {
		result1 executor.ExecutorResources
		result2 error
	}
	TotalResourcesStub        func(lager.Logger) (executor.ExecutorResources, error)
	totalResourcesMutex       sync.RWMutex
	totalResourcesArgsForCall []struct {
		arg1 lager.Logger
	}
	totalResourcesReturns struct {
		result1 executor.ExecutorResources
		result2 error
	}
	totalResourcesReturnsOnCall map[int]struct {
		result1 executor.ExecutorResources
		result2 error
	}
	GetFilesStub        func(logger lager.Logger, guid string, path string) (io.ReadCloser, error)
	getFilesMutex       sync.RWMutex
	getFilesArgsForCall []struct {
		logger lager.Logger
		guid   string
		path   string
	}
	getFilesReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	getFilesReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	VolumeDriversStub        func(logger lager.Logger) ([]string, error)
	volumeDriversMutex       sync.RWMutex
	volumeDriversArgsForCall []struct {
		logger lager.Logger
	}
	volumeDriversReturns struct {
		result1 []string
		result2 error
	}
	volumeDriversReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	SubscribeToEventsStub        func(lager.Logger) (executor.EventSource, error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToEventsReturns struct {
		result1 executor.EventSource
		result2 error
	}
	subscribeToEventsReturnsOnCall map[int]struct {
		result1 executor.EventSource
		result2 error
	}
	HealthyStub        func(lager.Logger) bool
	healthyMutex       sync.RWMutex
	healthyArgsForCall []struct {
		arg1 lager.Logger
	}
	healthyReturns struct {
		result1 bool
	}
	healthyReturnsOnCall map[int]struct {
		result1 bool
	}
	SetHealthyStub        func(lager.Logger, bool)
	setHealthyMutex       sync.RWMutex
	setHealthyArgsForCall []struct {
		arg1 lager.Logger
		arg2 bool
	}
	CleanupStub        func(lager.Logger)
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct {
		arg1 lager.Logger
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Ping(logger lager.Logger) error {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Ping", []interface{}{logger})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub(logger)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pingReturns.result1
}

func (fake *FakeClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeClient) PingArgsForCall(i int) lager.Logger {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return fake.pingArgsForCall[i].logger
}

func (fake *FakeClient) PingReturns(result1 error) {
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PingReturnsOnCall(i int, result1 error) {
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) AllocateContainers(logger lager.Logger, requests []executor.AllocationRequest) ([]executor.AllocationFailure, error) {
	var requestsCopy []executor.AllocationRequest
	if requests != nil {
		requestsCopy = make([]executor.AllocationRequest, len(requests))
		copy(requestsCopy, requests)
	}
	fake.allocateContainersMutex.Lock()
	ret, specificReturn := fake.allocateContainersReturnsOnCall[len(fake.allocateContainersArgsForCall)]
	fake.allocateContainersArgsForCall = append(fake.allocateContainersArgsForCall, struct {
		logger   lager.Logger
		requests []executor.AllocationRequest
	}{logger, requestsCopy})
	fake.recordInvocation("AllocateContainers", []interface{}{logger, requestsCopy})
	fake.allocateContainersMutex.Unlock()
	if fake.AllocateContainersStub != nil {
		return fake.AllocateContainersStub(logger, requests)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.allocateContainersReturns.result1, fake.allocateContainersReturns.result2
}

func (fake *FakeClient) AllocateContainersCallCount() int {
	fake.allocateContainersMutex.RLock()
	defer fake.allocateContainersMutex.RUnlock()
	return len(fake.allocateContainersArgsForCall)
}

func (fake *FakeClient) AllocateContainersArgsForCall(i int) (lager.Logger, []executor.AllocationRequest) {
	fake.allocateContainersMutex.RLock()
	defer fake.allocateContainersMutex.RUnlock()
	return fake.allocateContainersArgsForCall[i].logger, fake.allocateContainersArgsForCall[i].requests
}

func (fake *FakeClient) AllocateContainersReturns(result1 []executor.AllocationFailure, result2 error) {
	fake.AllocateContainersStub = nil
	fake.allocateContainersReturns = struct {
		result1 []executor.AllocationFailure
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AllocateContainersReturnsOnCall(i int, result1 []executor.AllocationFailure, result2 error) {
	fake.AllocateContainersStub = nil
	if fake.allocateContainersReturnsOnCall == nil {
		fake.allocateContainersReturnsOnCall = make(map[int]struct {
			result1 []executor.AllocationFailure
			result2 error
		})
	}
	fake.allocateContainersReturnsOnCall[i] = struct {
		result1 []executor.AllocationFailure
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetContainer(logger lager.Logger, guid string) (executor.Container, error) {
	fake.getContainerMutex.Lock()
	ret, specificReturn := fake.getContainerReturnsOnCall[len(fake.getContainerArgsForCall)]
	fake.getContainerArgsForCall = append(fake.getContainerArgsForCall, struct {
		logger lager.Logger
		guid   string
	}{logger, guid})
	fake.recordInvocation("GetContainer", []interface{}{logger, guid})
	fake.getContainerMutex.Unlock()
	if fake.GetContainerStub != nil {
		return fake.GetContainerStub(logger, guid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getContainerReturns.result1, fake.getContainerReturns.result2
}

func (fake *FakeClient) GetContainerCallCount() int {
	fake.getContainerMutex.RLock()
	defer fake.getContainerMutex.RUnlock()
	return len(fake.getContainerArgsForCall)
}

func (fake *FakeClient) GetContainerArgsForCall(i int) (lager.Logger, string) {
	fake.getContainerMutex.RLock()
	defer fake.getContainerMutex.RUnlock()
	return fake.getContainerArgsForCall[i].logger, fake.getContainerArgsForCall[i].guid
}

func (fake *FakeClient) GetContainerReturns(result1 executor.Container, result2 error) {
	fake.GetContainerStub = nil
	fake.getContainerReturns = struct {
		result1 executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetContainerReturnsOnCall(i int, result1 executor.Container, result2 error) {
	fake.GetContainerStub = nil
	if fake.getContainerReturnsOnCall == nil {
		fake.getContainerReturnsOnCall = make(map[int]struct {
			result1 executor.Container
			result2 error
		})
	}
	fake.getContainerReturnsOnCall[i] = struct {
		result1 executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RunContainer(arg1 lager.Logger, arg2 *executor.RunRequest) error {
	fake.runContainerMutex.Lock()
	ret, specificReturn := fake.runContainerReturnsOnCall[len(fake.runContainerArgsForCall)]
	fake.runContainerArgsForCall = append(fake.runContainerArgsForCall, struct {
		arg1 lager.Logger
		arg2 *executor.RunRequest
	}{arg1, arg2})
	fake.recordInvocation("RunContainer", []interface{}{arg1, arg2})
	fake.runContainerMutex.Unlock()
	if fake.RunContainerStub != nil {
		return fake.RunContainerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.runContainerReturns.result1
}

func (fake *FakeClient) RunContainerCallCount() int {
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	return len(fake.runContainerArgsForCall)
}

func (fake *FakeClient) RunContainerArgsForCall(i int) (lager.Logger, *executor.RunRequest) {
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	return fake.runContainerArgsForCall[i].arg1, fake.runContainerArgsForCall[i].arg2
}

func (fake *FakeClient) RunContainerReturns(result1 error) {
	fake.RunContainerStub = nil
	fake.runContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RunContainerReturnsOnCall(i int, result1 error) {
	fake.RunContainerStub = nil
	if fake.runContainerReturnsOnCall == nil {
		fake.runContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StopContainer(logger lager.Logger, guid string) error {
	fake.stopContainerMutex.Lock()
	ret, specificReturn := fake.stopContainerReturnsOnCall[len(fake.stopContainerArgsForCall)]
	fake.stopContainerArgsForCall = append(fake.stopContainerArgsForCall, struct {
		logger lager.Logger
		guid   string
	}{logger, guid})
	fake.recordInvocation("StopContainer", []interface{}{logger, guid})
	fake.stopContainerMutex.Unlock()
	if fake.StopContainerStub != nil {
		return fake.StopContainerStub(logger, guid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stopContainerReturns.result1
}

func (fake *FakeClient) StopContainerCallCount() int {
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	return len(fake.stopContainerArgsForCall)
}

func (fake *FakeClient) StopContainerArgsForCall(i int) (lager.Logger, string) {
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	return fake.stopContainerArgsForCall[i].logger, fake.stopContainerArgsForCall[i].guid
}

func (fake *FakeClient) StopContainerReturns(result1 error) {
	fake.StopContainerStub = nil
	fake.stopContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StopContainerReturnsOnCall(i int, result1 error) {
	fake.StopContainerStub = nil
	if fake.stopContainerReturnsOnCall == nil {
		fake.stopContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteContainer(logger lager.Logger, guid string) error {
	fake.deleteContainerMutex.Lock()
	ret, specificReturn := fake.deleteContainerReturnsOnCall[len(fake.deleteContainerArgsForCall)]
	fake.deleteContainerArgsForCall = append(fake.deleteContainerArgsForCall, struct {
		logger lager.Logger
		guid   string
	}{logger, guid})
	fake.recordInvocation("DeleteContainer", []interface{}{logger, guid})
	fake.deleteContainerMutex.Unlock()
	if fake.DeleteContainerStub != nil {
		return fake.DeleteContainerStub(logger, guid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteContainerReturns.result1
}

func (fake *FakeClient) DeleteContainerCallCount() int {
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	return len(fake.deleteContainerArgsForCall)
}

func (fake *FakeClient) DeleteContainerArgsForCall(i int) (lager.Logger, string) {
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	return fake.deleteContainerArgsForCall[i].logger, fake.deleteContainerArgsForCall[i].guid
}

func (fake *FakeClient) DeleteContainerReturns(result1 error) {
	fake.DeleteContainerStub = nil
	fake.deleteContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteContainerReturnsOnCall(i int, result1 error) {
	fake.DeleteContainerStub = nil
	if fake.deleteContainerReturnsOnCall == nil {
		fake.deleteContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ListContainers(arg1 lager.Logger) ([]executor.Container, error) {
	fake.listContainersMutex.Lock()
	ret, specificReturn := fake.listContainersReturnsOnCall[len(fake.listContainersArgsForCall)]
	fake.listContainersArgsForCall = append(fake.listContainersArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("ListContainers", []interface{}{arg1})
	fake.listContainersMutex.Unlock()
	if fake.ListContainersStub != nil {
		return fake.ListContainersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listContainersReturns.result1, fake.listContainersReturns.result2
}

func (fake *FakeClient) ListContainersCallCount() int {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	return len(fake.listContainersArgsForCall)
}

func (fake *FakeClient) ListContainersArgsForCall(i int) lager.Logger {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	return fake.listContainersArgsForCall[i].arg1
}

func (fake *FakeClient) ListContainersReturns(result1 []executor.Container, result2 error) {
	fake.ListContainersStub = nil
	fake.listContainersReturns = struct {
		result1 []executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListContainersReturnsOnCall(i int, result1 []executor.Container, result2 error) {
	fake.ListContainersStub = nil
	if fake.listContainersReturnsOnCall == nil {
		fake.listContainersReturnsOnCall = make(map[int]struct {
			result1 []executor.Container
			result2 error
		})
	}
	fake.listContainersReturnsOnCall[i] = struct {
		result1 []executor.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBulkMetrics(arg1 lager.Logger) (map[string]executor.Metrics, error) {
	fake.getBulkMetricsMutex.Lock()
	ret, specificReturn := fake.getBulkMetricsReturnsOnCall[len(fake.getBulkMetricsArgsForCall)]
	fake.getBulkMetricsArgsForCall = append(fake.getBulkMetricsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("GetBulkMetrics", []interface{}{arg1})
	fake.getBulkMetricsMutex.Unlock()
	if fake.GetBulkMetricsStub != nil {
		return fake.GetBulkMetricsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBulkMetricsReturns.result1, fake.getBulkMetricsReturns.result2
}

func (fake *FakeClient) GetBulkMetricsCallCount() int {
	fake.getBulkMetricsMutex.RLock()
	defer fake.getBulkMetricsMutex.RUnlock()
	return len(fake.getBulkMetricsArgsForCall)
}

func (fake *FakeClient) GetBulkMetricsArgsForCall(i int) lager.Logger {
	fake.getBulkMetricsMutex.RLock()
	defer fake.getBulkMetricsMutex.RUnlock()
	return fake.getBulkMetricsArgsForCall[i].arg1
}

func (fake *FakeClient) GetBulkMetricsReturns(result1 map[string]executor.Metrics, result2 error) {
	fake.GetBulkMetricsStub = nil
	fake.getBulkMetricsReturns = struct {
		result1 map[string]executor.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBulkMetricsReturnsOnCall(i int, result1 map[string]executor.Metrics, result2 error) {
	fake.GetBulkMetricsStub = nil
	if fake.getBulkMetricsReturnsOnCall == nil {
		fake.getBulkMetricsReturnsOnCall = make(map[int]struct {
			result1 map[string]executor.Metrics
			result2 error
		})
	}
	fake.getBulkMetricsReturnsOnCall[i] = struct {
		result1 map[string]executor.Metrics
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RemainingResources(arg1 lager.Logger) (executor.ExecutorResources, error) {
	fake.remainingResourcesMutex.Lock()
	ret, specificReturn := fake.remainingResourcesReturnsOnCall[len(fake.remainingResourcesArgsForCall)]
	fake.remainingResourcesArgsForCall = append(fake.remainingResourcesArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("RemainingResources", []interface{}{arg1})
	fake.remainingResourcesMutex.Unlock()
	if fake.RemainingResourcesStub != nil {
		return fake.RemainingResourcesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.remainingResourcesReturns.result1, fake.remainingResourcesReturns.result2
}

func (fake *FakeClient) RemainingResourcesCallCount() int {
	fake.remainingResourcesMutex.RLock()
	defer fake.remainingResourcesMutex.RUnlock()
	return len(fake.remainingResourcesArgsForCall)
}

func (fake *FakeClient) RemainingResourcesArgsForCall(i int) lager.Logger {
	fake.remainingResourcesMutex.RLock()
	defer fake.remainingResourcesMutex.RUnlock()
	return fake.remainingResourcesArgsForCall[i].arg1
}

func (fake *FakeClient) RemainingResourcesReturns(result1 executor.ExecutorResources, result2 error) {
	fake.RemainingResourcesStub = nil
	fake.remainingResourcesReturns = struct {
		result1 executor.ExecutorResources
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RemainingResourcesReturnsOnCall(i int, result1 executor.ExecutorResources, result2 error) {
	fake.RemainingResourcesStub = nil
	if fake.remainingResourcesReturnsOnCall == nil {
		fake.remainingResourcesReturnsOnCall = make(map[int]struct {
			result1 executor.ExecutorResources
			result2 error
		})
	}
	fake.remainingResourcesReturnsOnCall[i] = struct {
		result1 executor.ExecutorResources
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TotalResources(arg1 lager.Logger) (executor.ExecutorResources, error) {
	fake.totalResourcesMutex.Lock()
	ret, specificReturn := fake.totalResourcesReturnsOnCall[len(fake.totalResourcesArgsForCall)]
	fake.totalResourcesArgsForCall = append(fake.totalResourcesArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("TotalResources", []interface{}{arg1})
	fake.totalResourcesMutex.Unlock()
	if fake.TotalResourcesStub != nil {
		return fake.TotalResourcesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.totalResourcesReturns.result1, fake.totalResourcesReturns.result2
}

func (fake *FakeClient) TotalResourcesCallCount() int {
	fake.totalResourcesMutex.RLock()
	defer fake.totalResourcesMutex.RUnlock()
	return len(fake.totalResourcesArgsForCall)
}

func (fake *FakeClient) TotalResourcesArgsForCall(i int) lager.Logger {
	fake.totalResourcesMutex.RLock()
	defer fake.totalResourcesMutex.RUnlock()
	return fake.totalResourcesArgsForCall[i].arg1
}

func (fake *FakeClient) TotalResourcesReturns(result1 executor.ExecutorResources, result2 error) {
	fake.TotalResourcesStub = nil
	fake.totalResourcesReturns = struct {
		result1 executor.ExecutorResources
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TotalResourcesReturnsOnCall(i int, result1 executor.ExecutorResources, result2 error) {
	fake.TotalResourcesStub = nil
	if fake.totalResourcesReturnsOnCall == nil {
		fake.totalResourcesReturnsOnCall = make(map[int]struct {
			result1 executor.ExecutorResources
			result2 error
		})
	}
	fake.totalResourcesReturnsOnCall[i] = struct {
		result1 executor.ExecutorResources
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetFiles(logger lager.Logger, guid string, path string) (io.ReadCloser, error) {
	fake.getFilesMutex.Lock()
	ret, specificReturn := fake.getFilesReturnsOnCall[len(fake.getFilesArgsForCall)]
	fake.getFilesArgsForCall = append(fake.getFilesArgsForCall, struct {
		logger lager.Logger
		guid   string
		path   string
	}{logger, guid, path})
	fake.recordInvocation("GetFiles", []interface{}{logger, guid, path})
	fake.getFilesMutex.Unlock()
	if fake.GetFilesStub != nil {
		return fake.GetFilesStub(logger, guid, path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFilesReturns.result1, fake.getFilesReturns.result2
}

func (fake *FakeClient) GetFilesCallCount() int {
	fake.getFilesMutex.RLock()
	defer fake.getFilesMutex.RUnlock()
	return len(fake.getFilesArgsForCall)
}

func (fake *FakeClient) GetFilesArgsForCall(i int) (lager.Logger, string, string) {
	fake.getFilesMutex.RLock()
	defer fake.getFilesMutex.RUnlock()
	return fake.getFilesArgsForCall[i].logger, fake.getFilesArgsForCall[i].guid, fake.getFilesArgsForCall[i].path
}

func (fake *FakeClient) GetFilesReturns(result1 io.ReadCloser, result2 error) {
	fake.GetFilesStub = nil
	fake.getFilesReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetFilesReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.GetFilesStub = nil
	if fake.getFilesReturnsOnCall == nil {
		fake.getFilesReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.getFilesReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) VolumeDrivers(logger lager.Logger) ([]string, error) {
	fake.volumeDriversMutex.Lock()
	ret, specificReturn := fake.volumeDriversReturnsOnCall[len(fake.volumeDriversArgsForCall)]
	fake.volumeDriversArgsForCall = append(fake.volumeDriversArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("VolumeDrivers", []interface{}{logger})
	fake.volumeDriversMutex.Unlock()
	if fake.VolumeDriversStub != nil {
		return fake.VolumeDriversStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.volumeDriversReturns.result1, fake.volumeDriversReturns.result2
}

func (fake *FakeClient) VolumeDriversCallCount() int {
	fake.volumeDriversMutex.RLock()
	defer fake.volumeDriversMutex.RUnlock()
	return len(fake.volumeDriversArgsForCall)
}

func (fake *FakeClient) VolumeDriversArgsForCall(i int) lager.Logger {
	fake.volumeDriversMutex.RLock()
	defer fake.volumeDriversMutex.RUnlock()
	return fake.volumeDriversArgsForCall[i].logger
}

func (fake *FakeClient) VolumeDriversReturns(result1 []string, result2 error) {
	fake.VolumeDriversStub = nil
	fake.volumeDriversReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) VolumeDriversReturnsOnCall(i int, result1 []string, result2 error) {
	fake.VolumeDriversStub = nil
	if fake.volumeDriversReturnsOnCall == nil {
		fake.volumeDriversReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.volumeDriversReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEvents(arg1 lager.Logger) (executor.EventSource, error) {
	fake.subscribeToEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsReturnsOnCall[len(fake.subscribeToEventsArgsForCall)]
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("SubscribeToEvents", []interface{}{arg1})
	fake.subscribeToEventsMutex.Unlock()
	if fake.SubscribeToEventsStub != nil {
		return fake.SubscribeToEventsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.subscribeToEventsReturns.result1, fake.subscribeToEventsReturns.result2
}

func (fake *FakeClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return fake.subscribeToEventsArgsForCall[i].arg1
}

func (fake *FakeClient) SubscribeToEventsReturns(result1 executor.EventSource, result2 error) {
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 executor.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEventsReturnsOnCall(i int, result1 executor.EventSource, result2 error) {
	fake.SubscribeToEventsStub = nil
	if fake.subscribeToEventsReturnsOnCall == nil {
		fake.subscribeToEventsReturnsOnCall = make(map[int]struct {
			result1 executor.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsReturnsOnCall[i] = struct {
		result1 executor.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Healthy(arg1 lager.Logger) bool {
	fake.healthyMutex.Lock()
	ret, specificReturn := fake.healthyReturnsOnCall[len(fake.healthyArgsForCall)]
	fake.healthyArgsForCall = append(fake.healthyArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Healthy", []interface{}{arg1})
	fake.healthyMutex.Unlock()
	if fake.HealthyStub != nil {
		return fake.HealthyStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.healthyReturns.result1
}

func (fake *FakeClient) HealthyCallCount() int {
	fake.healthyMutex.RLock()
	defer fake.healthyMutex.RUnlock()
	return len(fake.healthyArgsForCall)
}

func (fake *FakeClient) HealthyArgsForCall(i int) lager.Logger {
	fake.healthyMutex.RLock()
	defer fake.healthyMutex.RUnlock()
	return fake.healthyArgsForCall[i].arg1
}

func (fake *FakeClient) HealthyReturns(result1 bool) {
	fake.HealthyStub = nil
	fake.healthyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) HealthyReturnsOnCall(i int, result1 bool) {
	fake.HealthyStub = nil
	if fake.healthyReturnsOnCall == nil {
		fake.healthyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.healthyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) SetHealthy(arg1 lager.Logger, arg2 bool) {
	fake.setHealthyMutex.Lock()
	fake.setHealthyArgsForCall = append(fake.setHealthyArgsForCall, struct {
		arg1 lager.Logger
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("SetHealthy", []interface{}{arg1, arg2})
	fake.setHealthyMutex.Unlock()
	if fake.SetHealthyStub != nil {
		fake.SetHealthyStub(arg1, arg2)
	}
}

func (fake *FakeClient) SetHealthyCallCount() int {
	fake.setHealthyMutex.RLock()
	defer fake.setHealthyMutex.RUnlock()
	return len(fake.setHealthyArgsForCall)
}

func (fake *FakeClient) SetHealthyArgsForCall(i int) (lager.Logger, bool) {
	fake.setHealthyMutex.RLock()
	defer fake.setHealthyMutex.RUnlock()
	return fake.setHealthyArgsForCall[i].arg1, fake.setHealthyArgsForCall[i].arg2
}

func (fake *FakeClient) Cleanup(arg1 lager.Logger) {
	fake.cleanupMutex.Lock()
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Cleanup", []interface{}{arg1})
	fake.cleanupMutex.Unlock()
	if fake.CleanupStub != nil {
		fake.CleanupStub(arg1)
	}
}

func (fake *FakeClient) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeClient) CleanupArgsForCall(i int) lager.Logger {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return fake.cleanupArgsForCall[i].arg1
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.allocateContainersMutex.RLock()
	defer fake.allocateContainersMutex.RUnlock()
	fake.getContainerMutex.RLock()
	defer fake.getContainerMutex.RUnlock()
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	fake.getBulkMetricsMutex.RLock()
	defer fake.getBulkMetricsMutex.RUnlock()
	fake.remainingResourcesMutex.RLock()
	defer fake.remainingResourcesMutex.RUnlock()
	fake.totalResourcesMutex.RLock()
	defer fake.totalResourcesMutex.RUnlock()
	fake.getFilesMutex.RLock()
	defer fake.getFilesMutex.RUnlock()
	fake.volumeDriversMutex.RLock()
	defer fake.volumeDriversMutex.RUnlock()
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	fake.healthyMutex.RLock()
	defer fake.healthyMutex.RUnlock()
	fake.setHealthyMutex.RLock()
	defer fake.setHealthyMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ executor.Client = new(FakeClient)
